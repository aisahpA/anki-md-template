<div class="markdown-body">
    {{Front}}
</div>


<script>
    var config = {
        /** log level： debug、info、error */
        logLevel: 'error',

        /** List of js to load */
        jsResources: [
            "https://gcore.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js",
            "https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js",
            "https://gcore.jsdelivr.net/npm/mermaid@11.6.0/dist/mermaid.min.js"
        ],

        /** Markdown-it options */
        markdownOptions: {
            html: true, // Enable HTML tags in source
            xhtmlOut: false, // Don't use '/' in single tags (<br />)
            breaks: true, // Convert '\n' in paragraphs into <br>
            linkify: true, // Autoconvert URL-like text to links
            typographer: false, // Enable smartypants and other typographic replacements
            highlight: function (str, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(str, {language: lang}).value
                    } catch (__) {
                    }
                } else if (lang === "mermaid") {
                    // Handle mermaid blocks specifically for the plugin
                    return `<pre class="mermaid">${str}</pre>`;
                }
                return '';
            },
        },

        /** Mermaid options */
        mermaidOptions: {
            theme: "default",
            startOnLoad: false,
        },
    }


    /**
     * Initializes the DivLog utility for logging messages to both console and a DOM element.
     * If DivLog is not already defined, it creates a new instance with methods for different log levels (debug, info, warn, error).
     * Each log message includes a timestamp and is styled according to its level.
     * Logs are appended to a dedicated container in the DOM, which is created if it doesn't exist.
     */
    function initDivLog() {
        if (typeof DivLog === 'undefined') {
            window.DivLog = {
                currentLevel: 4,
                levelMap: {debug: 5, info: 4, warn: 3, error: 2, off: 1},
                setLevel(levelStr) {
                    this.currentLevel = this.levelMap[levelStr];
                },
                debug(...messages) {
                    this._log(this.levelMap.debug, "", ...messages);
                },
                info(...messages) {
                    this._log(this.levelMap.info, "", ...messages);
                },
                warn(...messages) {
                    this._log(this.levelMap.warn, "orange", ...messages);
                },
                error(...messages) {
                    this._log(this.levelMap.error, "red", ...messages);
                },
                _log(minLevel, fontColor, ...messages) {
                    if (minLevel > this.currentLevel || messages.length === 0) {
                        return;
                    }
                    const messageDiv = document.createElement("div");
                    messageDiv.style.color = fontColor;
                    messages[0] = new Date().toLocaleTimeString() + "  " + messages[0];
                    messages.forEach(message => {
                        // 替换数学公式中的界定符号，原样显示，不然会被 anki 替换为公式形状
                        if (typeof message === 'string') {
                            message = message.replace(/\\\(/g, '\\_(').replace(/\\\[/g, '\\_[');
                        }
                        if (message instanceof Error) {
                            message = message.stack;
                        }
                        messageDiv.appendChild(document.createTextNode(message));
                        messageDiv.appendChild(document.createElement("br"));
                    });
                    messageDiv.appendChild(document.createElement("hr"));
                    this._getMsgContainer().appendChild(messageDiv)
                },
                _getMsgContainer() {
                    let msgContainer = document.getElementById("msgContainer");
                    if (!msgContainer) {
                        msgContainer = document.createElement("div");
                        msgContainer.id = "msgContainer";
                        msgContainer.style.textAlign = "left";
                        msgContainer.style.whiteSpace = "pre-wrap";
                        // 将日志信息放在最后
                        let qa = document.getElementById("qa");
                        if (qa) {
                            qa.appendChild(msgContainer);
                        }
                    }
                    return msgContainer
                },
                clearLogDiv() {
                    const msgContainer = document.getElementById("msgContainer");
                    if (msgContainer) {
                        msgContainer.remove();
                    }
                }
            };
        }
        DivLog.setLevel(globalThis.configLevel || config.logLevel || "info");
        DivLog.clearLogDiv();
    }

    /**
     * Loads a JavaScript resource.
     */
    function loadScript(url) {
        return new Promise((resolve, reject) => {
            let element = document.createElement("script");
            element.src = url;
            element.onload = () => {
                DivLog.info('Successfully loaded ' + url);
                resolve(); // Resolve for non-plugin resources
            };
            element.onerror = (e) => {
                DivLog.error(`Failed to load ${url}`, e);
                reject(e);
            };
            document.head.appendChild(element);
        });
    }

    /**
     * Initializes libraries (Markdown-it, Mermaid) after resources are loaded.
     * @returns {Promise<void>} Resolves when libraries are initialized or if non-critical parts fail.
     */
    function initializeLibs() {
        return new Promise((resolve, reject) => {
            try {
                initCensorUtil();

                window.AnkiMarkDownIt = window.markdownit(config.markdownOptions);
                DivLog.info("Markdown-it initialized.");

                mermaid.initialize(config.mermaidOptions);
                DivLog.info("Mermaid initialized.");

                resolve();
            } catch (initError) {
                showCard();
                DivLog.error("Critical error during library initialization", initError);
                reject(initError); // Reject if core initialization fails (like markdown-it)
            }
        });
    }

    /**
     * Initializes the CensorUtil utility if it hasn't been defined yet.
     *
     * CensorUtil provides functions to temporarily hide LaTeX math expressions (e.g., $$...$$, $...$)
     * during Markdown processing, ensuring they are not altered by intermediate transformations.
     * This is useful when rendering Markdown content that contains math formulas which should be preserved as-is.
     */
    function initCensorUtil() {
        if (typeof CensorUtil === 'undefined') {
            window.CensorUtil = {
                /**
                 * Regular expression to match LaTeX math expressions:
                 * - $$...$$
                 * - $(...)$
                 */
                MathJs_Reg: /(\\\[[\s\S]*?\\])|(\\\([\s\S]*?\\\))/g,
                MathJs_Replace: "ANKI_MATHJS_REPLACE",
                censor: function (note_text, regexp, mask) {
                    let matches = [];
                    let replacedText = note_text.replace(regexp, (match) => {
                        matches.push(match);
                        return mask;
                    });
                    return [replacedText, matches];
                },
                decensor: function (note_text, mask, replacements) {
                    if (replacements.length === 0) {
                        return note_text;
                    }
                    // Create an iterator to replace each mask in order
                    let replacementIterator = replacements[Symbol.iterator]();
                    // Replace all occurrences of mask in the text
                    return note_text.replace(new RegExp(mask, 'g'), () => {
                        return replacementIterator.next().value;
                    });
                }
            };
            DivLog.info("CensorUtil initialized.");
        }
    }

    /**
     * Renders Markdown content and Mermaid diagrams.
     *
     * This function attempts to find all elements with the class name 'markdown-body' and render their innerHTML content using Markdown formatting.
     * After Markdown rendering is complete, it will attempt to render any Mermaid diagrams present in the content.
     */
    function renderMarkDownFn() {
        try {
            // Process all '.markdown-body' elements and render their content using Markdown
            document.querySelectorAll('.markdown-body')
                .forEach((div) => {
                    div.innerHTML = renderMarkDown(div.innerHTML);
                });
            // Render Mermaid diagrams if any are present
            renderMermaid();
        } catch (e) {
            DivLog.error('Render markdown error: ', e);
        } finally {
            showCard();
        }
    }

    /**
     * Convert content to markdown web format
     * @param {string} text - The input text to be rendered
     * @returns {string} - Rendered HTML string
     */
    function renderMarkDown(text) {
        DivLog.debug("======================================");
        DivLog.debug("Original content：", text);

        let math_tag_matches;
        [text, math_tag_matches] = CensorUtil.censor(text, CensorUtil.MathJs_Reg, CensorUtil.MathJs_Replace);
        if (math_tag_matches.length > 0) {
            DivLog.debug("After hide \\ (...\\) 和 \\ [...\\]：", text);
        }

        text = text.trim()
            .replace(/&(amp|lt|gt|nbsp|quot|#39);/g, (_, type) => {
                const entities = {amp: '&', lt: '<', gt: '>', nbsp: ' '};
                return entities[type] || '';
            })
            .replace(/<br>/g, '\n');
        DivLog.debug("After reverse some HTML tags：", text);

        text = AnkiMarkDownIt.render(text);
        DivLog.debug("After markdown-it render:", text);

        text = CensorUtil.decensor(text, CensorUtil.MathJs_Replace, math_tag_matches);
        DivLog.debug("After restoring hidden content:", text);

        return text;
    }

    function renderMermaid() {
        const mermaidElements = document.querySelectorAll("pre.mermaid");
        if (mermaidElements.length > 0) {
            mermaidElements.forEach((el) => (el.style.display = "block")); // Ensure visible
            try {
                // Use mermaid.run() - preferred for dynamic content
                mermaid
                    .run({nodes: mermaidElements})
                    .then(() => {
                        // console.log("Mermaid rendering complete.");
                        // Optional: Hide original <pre> if needed
                        // mermaidElements.forEach(el => el.style.display = 'none');
                    })
                    .catch((mermaidError) => {
                        DivLog.error("Mermaid rendering failed", mermaidError);
                    });
            } catch (mermaidError) {
                DivLog.error("Error calling mermaid.run()", mermaidError);
            }
        }
    }


    function showCard() {
        const card = document.querySelector(".card");
        if (card) {
            card.classList.add("card-show");
        }
    }

    function getRunPipeline() {
        return () => {
            if (globalThis.hasInitResource) {
                renderMarkDownFn();
            } else {
                globalThis.hasInitResource = true;
                Promise.all(config.jsResources.map(loadScript))
                    .then(() => {
                        return initializeLibs();
                    })
                    .then(() => {
                        renderMarkDownFn();
                    })
            }
        };
    }

    function main() {
        initDivLog();

        const runPipeline = getRunPipeline();

        if (globalThis.onUpdateHook) {
            DivLog.info("onUpdateHook exists, add to onUpdateHook")
            onUpdateHook.push(runPipeline);
        } else {
            runPipeline();
        }
    }

    main();
</script>
